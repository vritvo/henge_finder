<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Henge Finder</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #5E4955;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.08);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #2A2B2A;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .instructions {
            background: #fff;
            border-left: 4px solid #978897;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
        }

        .instructions h3 {
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .instructions p {
            color: #2A2B2A;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .instructions p:last-child {
            margin-bottom: 0;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #5E4955;
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
            background: #fff;
            color: #2A2B2A;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #5E4955;
        }

        button {
            width: 100%;
            padding: 15px;
            background: #5E4955;
            color: #fff3ec;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            background: #4f3d47;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            text-align: center;
            color: #2A2B2A;
            margin-top: 20px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #5E4955;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .result.success {
            background: #e7f7f0;
            border: 1px solid #b0e0d3;
            color: #2A2B2A;
            display: block;
        }

        .result.address {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            color: #2A2B2A;
            display: block;
        }

        .result.error {
            background: #fbe6ec;
            border: 1px solid #f5c6cb;
            color: #5E4955;
            display: block;
        }

        .result.no-henge {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            display: block;
        }

        .result h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
            color: #5E4955;
        }

        .result p {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .highlight {
            font-weight: 600;
            color: #996888;
        }

        .coordinates {
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            color: #2A2B2A;
        }

        .disclaimer {
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
            border-left: 3px solid #5E4955;
        }

        .disclaimer p {
            margin: 0;
            font-size: 0.9em;
            color: #2A2B2A;
            line-height: 1.4;
        }
        
        .disclaimer p:not(:last-child) {
            margin-bottom: 15px;
        }
        
        .disclaimer .topic {
            font-weight: 700;
            color: #5E4955;
            margin-bottom: 5px;
        }

        .map-container {
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #e1e5e9;
        }

        .step-instructions {
            background: #f8f9fa;
            padding: 15px;
            margin: 0 0 15px 0;
            border-left: 4px solid #DC816E;
            border-radius: 0 8px 8px 0;
        }

        .step-instructions p {
            margin: 0;
            color: #2A2B2A;
            line-height: 1.5;
            font-size: 0.95em;
        }

        #map {
            height: 500px;
            width: 100%;
            position: relative;
        }

        .compass-container {
            position: relative;
            padding: 0 30px;
        }

        .compass-marker {
            position: absolute;
            background: rgba(94, 73, 85, 0.9);
            color: white;
            font-weight: bold;
            font-size: 14px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .compass-north {
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-south {
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-east {
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-west {
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .map-info {
            background: #f8f9fa;
            padding: 10px;
            border-top: 1px solid #e1e5e9;
            font-size: 0.9em;
            color: #2A2B2A;
        }

        .bearing-controls {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #e1e5e9;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bearing-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bearing-value {
            font-weight: bold;
            color: #5E4955;
            font-size: 1.1em;
        }

        .bearing-buttons {
            display: flex;
            gap: 10px;
        }

        .bearing-btn {
            padding: 8px 12px;
            background: #5E4955;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .bearing-btn:hover {
            background: #4f3d47;
        }

        .bearing-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .reset-btn {
            background: #6c757d;
        }

        .reset-btn:hover {
            background: #5a6268;
        }

        .main-action {
            margin-top: 20px;
            text-align: center;
        }

        .main-btn {
            padding: 18px 30px;
            background: #5E4955;
            color: #fff3ec;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s;
            min-width: 200px;
        }

        .main-btn:hover {
            transform: translateY(-2px);
            background: #4f3d47;
        }

        .main-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .spinner-hint {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Interactive arrow styling */
        .interactive-arrow {
            cursor: grab;
            transition: opacity 0.2s;
        }

        .interactive-arrow:hover {
            opacity: 1 !important;
        }

        .arrow-handle {
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing !important;
        }

        body.grabbing .interactive-arrow,
        body.grabbing .arrow-handle {
            cursor: grabbing !important;
        }

        /* Toggle/Summary hover effects */
        summary:hover {
            background-color: #e9ecef !important;
        }

        /* Tooltip styles */
        .tooltip-term {
            color: #996888;
            text-decoration: underline;
            text-decoration-style: dotted;
            cursor: help;
            position: relative;
            font-weight: 600;
        }

        .tooltip-term:hover {
            color: #5E4955;
        }

        .tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #5E4955;
            color: #fff3ec;
            text-align: center;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: normal;
            line-height: 1.4;
            white-space: normal;
            width: 200px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: opacity 0.2s, visibility 0.2s;
        }

        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #5E4955 transparent transparent transparent;
        }

        .tooltip-term:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }


        /* Mobile block styles */
        .mobile-block {
            display: none;
            min-height: 100vh;
            background: #5E4955;
            color: #fff3ec;
            padding: 40px 20px;
            text-align: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .mobile-block h1 {
            color: #fff3ec;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .mobile-block p {
            font-size: 1.1em;
            line-height: 1.6;
            max-width: 400px;
            margin-bottom: 15px;
        }

        .mobile-block .icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        /* Tab navigation styles */
        .tab-navigation {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #e1e5e9;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #2A2B2A;
            transition: all 0.3s ease;
        }

        .tab-button:hover {
            background: #f8f9fa;
            transform: none;
        }

        .tab-button.active {
            color: #5E4955;
            border-bottom-color: #5E4955;
            background: #f8f9fa;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Educational content styles */
        .education-section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #978897;
        }

        .education-section h2 {
            color: #5E4955;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .education-section h3 {
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 1.3em;
            margin-top: 20px;
        }

        .education-section h3:first-of-type {
            margin-top: 0;
        }

        .education-section p {
            color: #2A2B2A;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .education-section ul {
            color: #2A2B2A;
            line-height: 1.6;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .education-section li {
            margin-bottom: 8px;
        }

        .degree-highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            color: #856404;
        }

        .example-box {
            background: #e7f7f0;
            border: 1px solid #b0e0d3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .example-box h4 {
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .example-box p {
            margin-bottom: 10px;
        }

        .example-box:last-child {
            margin-bottom: 0;
        }

        .key-concept {
            background: #fff;
            border: 2px solid #5E4955;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .key-concept h3 {
            color: #5E4955;
            margin-bottom: 10px;
        }

        .key-concept p {
            margin: 0;
            font-size: 1.1em;
            font-weight: 500;
        }

        /* Solar System Visualization */
        .solar-system-container {
            background: #1a1a2e;
            border-radius: 10px;
            margin: 30px 0;
            padding: 20px;
            position: relative;
        }

        .solar-system-canvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            display: block;
            background: radial-gradient(circle at center, #16213e 0%, #0f0f23 100%);
        }

        .time-controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .time-slider-container {
            margin: 15px 0;
        }

        .time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .time-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
        }

        .time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
            border: none;
        }

        /* Orbital visualization slider styles */
        #orbitalTimeSlider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
        }

        #orbitalTimeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
            border: none;
        }

        .time-display {
            color: white;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .equinox-indicator {
            color: #ffd700;
            font-weight: bold;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .equinox-indicator.visible {
            opacity: 1;
        }

        .play-pause-btn {
            background: #5E4955;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 10px;
        }

        .play-pause-btn:hover {
            background: #4f3d47;
        }

        /* Street Henge Visualization */
        .street-henge-container {
            background: #87CEEB;
            border-radius: 10px;
            margin: 30px 0;
            padding: 20px;
            position: relative;
        }

        .street-henge-canvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #FFE4B5 30%, #FFA07A 70%, #FF6347 100%);
        }

        .street-time-controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .street-time-slider-container {
            margin: 15px 0;
        }

        .street-time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .street-time-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
        }

        .street-time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5E4955;
            cursor: pointer;
            border: none;
        }

        .street-time-display {
            color: #2A2B2A;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .street-time-labels {
            display: flex;
            justify-content: space-between;
            color: #2A2B2A;
            font-size: 14px;
            margin-top: 5px;
        }

        .henge-indicator {
            color: #ffd700;
            font-weight: bold;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .henge-indicator.visible {
            opacity: 1;
        }

    </style>
</head>
<body>
    <!-- Mobile block message -->
    <div class="mobile-block" id="mobileBlock">
        <h1>Desktop Required</h1>
        <p>Henge Finder requires a desktop or laptop computer.</p>
        <p>Please visit this site on a desktop browser to find your street's henge alignment.</p>
    </div>

    <div class="container" id="mainContainer">
        <h1>Henge Finder</h1>
        
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="showTab('finder')">Find a Henge</button>
            <button class="tab-button" onclick="showTab('learn')">How It Works</button>
        </div>

        <!-- Finder Tab Content -->
        <div class="tab-content active" id="finder-tab">
            <div class="instructions">
                <details>
                    <summary style="cursor: pointer; color: #5E4955; font-weight: 600; margin-bottom: 10px; padding: 15px; border-radius: 8px; background: #f8f9fa; border: 1px solid #e1e5e9; transition: background-color 0.2s;">
                        <span style="font-size: 1.4em;">What is a henge?</span>
                    </summary>
                    <div style="display: flex; align-items: flex-start; gap: 20px; margin-top: 15px;">
                        <div style="flex: 1;">
                            <p style="color: #2A2B2A; line-height: 1.6; margin-bottom: 15px;">A 'henge' is when the sun sets perfectly in line with your street, creating a dramatic view ‚Äî like <a href="https://en.wikipedia.org/wiki/Manhattanhenge" target="_blank" style="color: #996888; text-decoration: none;">Manhattanhenge</a> in New York.</p>
                            <p style="color: #2A2B2A; line-height: 1.6; margin-bottom: 0;">Use this tool to find when the next henge will happen for your street.</p>
                        </div>
                        <div style="flex-shrink: 0; max-width: 300px;">
                            <img src="{{ url_for('static', filename='images/city_henge.png') }}" 
                                 alt="Example of a street henge with the sun aligned down a city street" 
                                 style="width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                        </div>
                    </div>
                </details>
            </div>

            <div class="instructions">
                <details>
                    <summary style="cursor: pointer; color: #5E4955; font-weight: 600; margin-bottom: 10px; padding: 15px; border-radius: 8px; background: #f8f9fa; border: 1px solid #e1e5e9; transition: background-color 0.2s;">
                        <span style="font-size: 1.4em;">What makes a good street for a henge?</span>
                    </summary>
                    <p style="color: #2A2B2A; margin-bottom: 15px;"><em>(Tips for finding the best henge view)</em></p>
                    <ul style="color: #2A2B2A; line-height: 1.6; margin-left: 20px; margin-bottom: 20px;">
                        <li><strong>Pick a long, straight road with a clear view of the horizon.</strong><br>
                        Henges work best when you can actually see the sun touch the horizon. Curvy streets won't align well, and wider streets tend to give better views.</li>
                        <li><strong>Aim for a mostly east‚Äìwest street.</strong><br>
                        The sun won't set along a north‚Äìsouth road. It doesn't have to be perfect ‚Äî the sunset shifts a little each day.</li>
                        <li><strong>Avoid entering an intersection address if possible.</strong><br>
                        It's not necessary for this to work, but it will be faster.</li>
                    </ul>
                    <p style="color: #2A2B2A; margin-bottom: 10px;"><strong>Example Streets:</strong></p>
                    <ul style="color: #2A2B2A; line-height: 1.6; margin-left: 20px;">
                        <li><a href="https://www.google.com/maps/place/251+W+42nd+St,+New+York,+NY+10036/@40.7570115,-73.9893081,18z/data=!4m15!1m8!3m7!1s0x89c2585360bfe5e7:0xd3b373353146c43f!2s251+W+42nd+St,+New+York,+NY+10036!3b1!8m2!3d40.757119!4d-73.9891884!16s%2Fg%2F11nnknww84!3m5!1s0x89c2585360bfe5e7:0xd3b373353146c43f!8m2!3d40.757119!4d-73.9891884!16s%2Fg%2F11nnknww84?entry=ttu&g_ep=EgoyMDI1MDczMC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">251 W 42nd St, New York, NY</a>, by Times Square</li>
                        <li><a href="https://www.google.com/maps/place/601+E+76th+St,+Chicago,+IL+60619/@41.756679,-87.61279,17z/data=!3m1!4b1!4m5!3m4!1s0x880e28c816730d29:0x111671091e24efc4!8m2!3d41.756675!4d-87.6102151?entry=ttu&g_ep=EgoyMDI1MDczMC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">601-615 E 76th St, Chicago, IL</a></li>
                        <li><a href="https://www.google.com/maps/place/Haarlemmerweg+109-C,+1051+KV+Amsterdam,+Netherlands/@52.3853326,4.8733117,19z/data=!3m1!4b1!4m6!3m5!1s0x47c609d5b0e41589:0xf6191c1b666122c1!8m2!3d52.3853318!4d4.8739554!16s%2Fg%2F11nnkplcpz?entry=ttu&g_ep=EgoyMDI1MDgyNC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">Haarlemmerweg 109-C, 1051 KV Amsterdam, Netherlands</a>, along the canal by the Wester Park</li>
                    </ul>
                </details>
            </div>
            <form id="hengeForm">
                <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em;">Step 1: Enter an address</h3>
                <div class="form-group">
                    <input type="text" id="address" name="address" placeholder="e.g., 251 W 42nd St, New York, NY 10036" required>
                </div>
                <button type="submit" id="submitBtn">Find Address</button>
            </form>

            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>May take a second...</p>
            </div>

            <div class="result" id="addressResult"></div>
            
            <div class="map-container" id="mapContainer" style="display: none;">
                <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em;">Step 2: Adjust the arrow to match the street's direction</h3>
                <div class="step-instructions">
                    <p>We've estimated your street's direction from map data. <strong>If the arrow aligns with your street, you're all set!</strong> If not, drag the arrow handle to match the street direction you want the henge for.</p>
                </div>
                <div class="compass-container">
                    <div class="compass-marker compass-north">N</div>
                    <div class="compass-marker compass-south">S</div>
                    <div class="compass-marker compass-east">E</div>
                    <div class="compass-marker compass-west">W</div>
                    <div id="map"></div>
                </div>
                <div class="bearing-controls">
                    <div class="bearing-info">
                        <span>Road <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span>
                        <span class="bearing-value" id="bearingValue">0¬∞</span>
                    </div>
                    <div class="bearing-buttons">
                        <button class="bearing-btn reset-btn" id="resetBtn">Reset to Original</button>
                    </div>
                </div>
                <div class="map-info">
                    <strong>Map Legend:</strong> Dark arrow shows the road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span> direction (drag to adjust).
                </div>
                <div class="main-action">
                    <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em; text-align: left;">Step 3: Find henge</h3>
                    <button class="main-btn" id="calculateHengeBtn">Let's go!</button>
                </div>
            </div>

            <div class="result" id="hengeResult" style="display: none;"></div>
        </div>

        <!-- Learn Tab Content -->
        <div class="tab-content" id="learn-tab">
            <!-- Street Henge Visualization -->
            <div class="education-section">
                <h2>üèôÔ∏è See How the Sun Moves Down Your Street</h2>
                <p>Watch how the sun's position changes throughout the day, and see why henges only happen at specific times:</p>
                
                <div class="street-henge-container">
                    <canvas id="streetHengeCanvas" class="street-henge-canvas"></canvas>
                    <div class="street-time-controls">
                        <div class="street-time-display" id="streetTimeDisplay">6:00 PM</div>
                        <div class="street-time-slider-container">
                            <input type="range" id="streetTimeSlider" class="street-time-slider" min="0" max="240" value="120" step="1">
                        </div>
                        <div class="street-time-labels">
                            <span>4:00 PM</span>
                            <span>8:00 PM</span>
                        </div>
                        <div class="henge-indicator" id="hengeIndicator">üåÖ Perfect Henge Alignment!</div>
                    </div>
                </div>
                
                <p style="margin-top: 20px;"><em>This shows a typical Manhattan street (299¬∞ bearing). Notice how the sun only aligns perfectly with the street at specific times!</em></p>
            </div>

            <!-- Orbital Mechanics Visualization -->
            <div class="education-section">
                <h2>üåç Earth's Orbital Motion and Axial Tilt</h2>
                <p>Understanding why henges happen requires looking at Earth's motion around the Sun. These visualizations show how Earth's tilt and orbital position change throughout the year:</p>
                
                <div style="display: flex; gap: 20px; margin: 30px 0;">
                    <!-- Orbital View Canvas -->
                    <div style="flex: 1;">
                        <h3 style="text-align: center; color: #5E4955; margin-bottom: 15px;">Earth's Orbit (Top View)</h3>
                        <div style="background: #1a1a2e; border-radius: 10px; padding: 20px;">
                            <canvas id="orbitalCanvas" style="width: 100%; height: 300px; border-radius: 8px; display: block; background: radial-gradient(circle at center, #16213e 0%, #0f0f23 100%);"></canvas>
                        </div>
                    </div>
                    
                    <!-- Tilt View Canvas -->
                    <div style="flex: 1;">
                        <h3 style="text-align: center; color: #5E4955; margin-bottom: 15px;">Earth's Tilt (Side View)</h3>
                        <div style="background: #1a1a2e; border-radius: 10px; padding: 20px;">
                            <canvas id="tiltCanvas" style="width: 100%; height: 300px; border-radius: 8px; display: block; background: radial-gradient(circle at center, #16213e 0%, #0f0f23 100%);"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Shared Controls -->
                <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin-top: 20px;">
                    <div style="color: white; font-size: 18px; font-weight: 600; margin-bottom: 10px; text-align: center;" id="orbitalTimeDisplay">Day 1 of Year (January 1)</div>
                    <div style="margin: 15px 0;">
                        <input type="range" id="orbitalTimeSlider" style="width: 100%; height: 8px; border-radius: 4px; background: #ddd; outline: none; -webkit-appearance: none;" min="0" max="365" value="0" step="1">
                    </div>
                    <div style="display: flex; justify-content: space-between; color: white; font-size: 14px; margin-top: 5px;">
                        <span>January 1</span>
                        <span>June 21 (Summer Solstice)</span>
                        <span>December 31</span>
                    </div>
                    <div style="color: #ffd700; font-weight: bold; margin-top: 10px; opacity: 0; transition: opacity 0.3s; text-align: center;" id="orbitalEquinoxIndicator">üåÖ Equinox - Sun sets due west!</div>
                </div>
                
                <p style="margin-top: 20px;"><em>The orbital view shows Earth's position around the Sun throughout the year. The tilt view shows how the North Pole's orientation relative to the Sun changes, affecting where the Sun appears to set.</em></p>
            </div>

            <div class="education-section">
                <h2>üåÖ Why Do Henges Happen So Rarely?</h2>
                <p>You might think that henges would happen all the time for any east-west street, but they're actually quite rare! Here's why:</p>
                
                <div class="key-concept">
                    <h3>üåç Earth's Tilt Changes Everything</h3>
                    <p>Earth is tilted <span class="degree-highlight">~23.5¬∞</span> on its axis, which means the sun's path across the sky changes throughout the year.</p>
                </div>

                <h3>The Sun's Changing Path</h3>
                <p>The sun only sets at <strong>true west (270¬∞)</strong> twice a year ‚Äî during the spring and fall equinoxes. For the rest of the year, it sets either north or south of true west:</p>
                
                <div class="solar-system-container">
                    <canvas id="solarSystemCanvas" class="solar-system-canvas"></canvas>
                    <div class="time-controls">
                        <div class="time-display" id="timeDisplay">Day 1 of Year</div>
                        <div class="time-slider-container">
                            <input type="range" id="timeSlider" class="time-slider" min="0" max="365" value="0" step="1">
                        </div>
                        <button id="playPauseBtn" class="play-pause-btn">‚ñ∂ Play</button>
                        <div class="equinox-indicator" id="equinoxIndicator">üåÖ Equinox - Sun sets due west!</div>
                    </div>
                </div>
            </div>

            <div class="education-section">
                <h2>üåû Why This Creates Rare Alignments</h2>
                <p>Most city streets aren't perfectly aligned with true east-west. This creates interesting alignment patterns:</p>

                <div class="example-box">
                    <h4>üèôÔ∏è Chicago Example</h4>
                    <p><strong>Street bearing:</strong> <span class="degree-highlight">270¬∞</span> (true east-west)</p>
                    <p><strong>Henge dates:</strong> Spring and fall equinoxes (around March 20 & September 22)</p>
                    <p>Chicago's grid is aligned with the cardinal directions, so henges happen when the sun sets due west.</p>
                </div>

                <div class="example-box">
                    <h4>üóΩ Manhattan Example</h4>
                    <p><strong>Street bearing:</strong> <span class="degree-highlight">299¬∞</span> (northwest orientation)</p>
                    <p><strong>Henge dates:</strong> Late May and mid-July</p>
                    <p>Manhattan's grid is rotated, so henges happen when the sun's path matches this tilted orientation ‚Äî which only occurs twice per year as the sun's path shifts from summer to winter patterns.</p>
                </div>
            </div>

            <div class="education-section">
                <h2>üåû The Science Behind Henges</h2>
                
                <h3>Earth's Axial Tilt</h3>
                <p>Earth's <span class="degree-highlight">23.5¬∞</span> tilt is what gives us seasons. This tilt also means the sun's position at sunset moves in a predictable pattern throughout the year:</p>
                <ul>
                    <li><strong>Summer solstice:</strong> Sun sets furthest north of west</li>
                    <li><strong>Winter solstice:</strong> Sun sets furthest south of west</li>
                    <li><strong>Equinoxes:</strong> Sun sets due west</li>
                </ul>

                <h3>Street Orientation Matters</h3>
                <p>The key to a henge is the relationship between your street's orientation and the sun's seasonal path:</p>
                <ul>
                    <li><strong>Perfect east-west streets (270¬∞):</strong> Get henges at equinoxes</li>
                    <li><strong>Northwest-oriented streets:</strong> Get henges in late spring/early summer</li>
                    <li><strong>Southwest-oriented streets:</strong> Get henges in late summer/early winter</li>
                    <li><strong>North-south streets:</strong> Never get henges (sun doesn't set along them)</li>
                </ul>

                <h3>Why Only Twice Per Year?</h3>
                <p>For any given street orientation, the sun's azimuth (compass direction) at sunset matches that orientation exactly twice as it sweeps through its annual cycle. Think of it like a pendulum ‚Äî it passes through any given point twice per swing.</p>
            </div>

            <div class="education-section">
                <h2>üîç Technical Details</h2>
                
                <h3>What This Tool Calculates</h3>
                <p>This henge finder looks for when the sun's azimuth (compass direction) at <span class="degree-highlight">0.5¬∞ altitude</span> matches your street's bearing within <span class="degree-highlight">1¬∞</span>.</p>
                
                <h3>Why 0.5¬∞ Altitude?</h3>
                <p>We use 0.5¬∞ above the horizon instead of exactly at sunset because:</p>
                <ul>
                    <li>It's when the sun appears largest and most dramatic</li>
                    <li>It accounts for atmospheric refraction</li>
                    <li>It provides the best viewing experience before the sun disappears</li>
                </ul>

                <h3>Street Bearing Detection</h3>
                <p>The tool automatically detects your street's orientation using OpenStreetMap data, but you can adjust it manually if needed. Street bearings are measured clockwise from true north (0¬∞ = north, 90¬∞ = east, 180¬∞ = south, 270¬∞ = west).</p>
            </div>

            <div class="education-section">
                <h2>üåé Famous Henges Around the World</h2>
                
                <div class="example-box">
                    <h4>Manhattanhenge (New York)</h4>
                    <p>The most famous urban henge, occurring around May 28 and July 13 when the sun aligns with Manhattan's tilted street grid.</p>
                </div>

                <div class="example-box">
                    <h4>Chicagohenge (Chicago)</h4>
                    <p>Happens during equinoxes when the sun sets due west along Chicago's cardinal-aligned streets.</p>
                </div>

                <div class="example-box">
                    <h4>Torontohenge (Toronto)</h4>
                    <p>Occurs along Toronto's east-west streets, with timing similar to other cities at similar latitudes.</p>
                </div>

                <p><em>Try the finder tool with addresses from these cities to see their henge patterns!</em></p>
            </div>
        </div>
    </div>    <script>
        // Mobile detection and blocking
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Check for mobile user agents - this catches phones, tablets, etc.
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            const isMobileUserAgent = mobileRegex.test(userAgent.toLowerCase());
            
            // Check for touch-only devices (but exclude desktop touch screens)
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const hasMouseSupport = window.matchMedia('(pointer: fine)').matches;
            const isTouchOnly = isTouchDevice && !hasMouseSupport;
            
            // Block if mobile user agent OR touch-only device (excludes desktop touch screens)
            return isMobileUserAgent || isTouchOnly;
        }

        function initializeApp() {
            if (isMobileDevice()) {
                // Show mobile block, hide main content
                document.getElementById('mobileBlock').style.display = 'flex';
                document.getElementById('mainContainer').style.display = 'none';
                return;
            }
            
            // Hide mobile block, show main content
            document.getElementById('mobileBlock').style.display = 'none';
            document.getElementById('mainContainer').style.display = 'block';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Re-check on window resize (in case user rotates device or resizes browser)
        window.addEventListener('resize', initializeApp);

        let map = null;
        let marker = null;
        let currentAddress = null;
        let currentCoordinates = null;
        let originalBearing = 0;
        let currentBearing = 0;
        let originalZoom = 18;
        let isInteractiveMode = false;
        let isDragging = false;

        // Unified arrow management
        class ArrowManager {
            constructor(map) {
                this.map = map;
                this.arrowGroup = null;
                this.isInteractive = false;
            }

            createArrow(lat, lon, bearing, options = {}) {
                const {
                    color = '#2A2B2A',
                    weight = 4,
                    opacity = 0.8,
                    length = 100,
                    interactive = false
                } = options;

                // Clear existing arrow
                this.clear();

                // Calculate arrow endpoint
                const start = [lon, lat];
                const destination = turf.destination(start, length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Create arrow line
                const arrowLine = L.polyline([[lat, lon], [endLat, endLon]], {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    className: interactive ? 'interactive-arrow' : ''
                });

                // Create arrowhead
                const arrowheadLines = this.createArrowhead(destination, bearing, color, weight, opacity);

                // Create handle if interactive
                let handle = null;
                if (interactive) {
                    handle = L.marker([endLat, endLon], {
                        icon: L.divIcon({
                            className: 'arrow-handle',
                            html: '<div style="background-color: #2A2B2A; width: 24px; height: 24px; border-radius: 50%; border: 3px solid #fff; cursor: grab;"></div>',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    });
                }

                // Group all elements
                this.arrowGroup = {
                    line: arrowLine,
                    arrowheads: arrowheadLines,
                    handle: handle,
                    center: [lat, lon],
                    bearing: bearing,
                    length: length
                };

                // Add to map
                arrowLine.addTo(this.map);
                arrowheadLines.forEach(line => line.addTo(this.map));
                if (handle) handle.addTo(this.map);

                this.isInteractive = interactive;
                return this.arrowGroup;
            }

            createArrowhead(destination, bearing, color, weight, opacity) {
                const arrowheadLength = 30;
                const arrowheadAngle = 30;
                
                const arrowhead1 = turf.destination(destination, arrowheadLength, bearing + 180 - arrowheadAngle, {units: 'meters'});
                const arrowhead2 = turf.destination(destination, arrowheadLength, bearing + 180 + arrowheadAngle, {units: 'meters'});
                
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];
                
                const line1 = L.polyline([[endLat, endLon], [arrowhead1.geometry.coordinates[1], arrowhead1.geometry.coordinates[0]]], {
                    color: color,
                    weight: weight,
                    opacity: opacity
                });
                
                const line2 = L.polyline([[endLat, endLon], [arrowhead2.geometry.coordinates[1], arrowhead2.geometry.coordinates[0]]], {
                    color: color,
                    weight: weight,
                    opacity: opacity
                });

                return [line1, line2];
            }

            updateArrow(bearing, updateHandle = true) {
                if (!this.arrowGroup) return;

                const [lat, lon] = this.arrowGroup.center;
                const start = [lon, lat];
                const destination = turf.destination(start, this.arrowGroup.length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Update arrow line
                this.arrowGroup.line.setLatLngs([[lat, lon], [endLat, endLon]]);

                // Update arrowhead
                const newArrowheads = this.createArrowhead(destination, bearing, 
                    this.arrowGroup.line.options.color, 
                    this.arrowGroup.line.options.weight, 
                    this.arrowGroup.line.options.opacity);

                // Remove old arrowheads
                this.arrowGroup.arrowheads.forEach(line => this.map.removeLayer(line));

                // Add new arrowheads
                newArrowheads.forEach(line => line.addTo(this.map));
                this.arrowGroup.arrowheads = newArrowheads;

                // Update handle if not dragging
                if (updateHandle && this.arrowGroup.handle) {
                    this.arrowGroup.handle.setLatLng([endLat, endLon]);
                }

                this.arrowGroup.bearing = bearing;
            }

            clear() {
                if (this.arrowGroup) {
                    this.map.removeLayer(this.arrowGroup.line);
                    this.arrowGroup.arrowheads.forEach(line => this.map.removeLayer(line));
                    if (this.arrowGroup.handle) {
                        this.map.removeLayer(this.arrowGroup.handle);
                    }
                    this.arrowGroup = null;
                }
            }

            addSunArrow(lat, lon, bearing, color = '#DC816E', length = 70) {
                // Calculate arrow endpoint
                const start = [lon, lat];
                const destination = turf.destination(start, length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Create arrow line with transparency
                const arrowLine = L.polyline([[lat, lon], [endLat, endLon]], {
                    color: color,
                    weight: 4,
                    opacity: 0.8
                });

                // Create arrowhead
                const arrowheadLines = this.createArrowhead(destination, bearing, color, 4, 0.8);

                // Add to map
                arrowLine.addTo(this.map);
                arrowheadLines.forEach(line => line.addTo(this.map));

                return {
                    line: arrowLine,
                    arrowheads: arrowheadLines
                };
            }
        }

        let arrowManager = null;

        // Function to display address lookup results
        function displayAddressLookup(data) {
            const addressResultDiv = document.getElementById('addressResult');
            
            let html = `
                <p><span class="highlight">Address:</span> ${data.address}</p>
                <div class="coordinates">
                    <strong>Coordinates:</strong> ${data.coordinates.lat.toFixed(6)}, ${data.coordinates.lon.toFixed(6)}
                </div>
            `;
            
            addressResultDiv.innerHTML = html;
            addressResultDiv.className = 'result address';
            addressResultDiv.style.display = 'block';
            
            // Display the map with interactive arrow
            displayMap(data.coordinates.lat, data.coordinates.lon, data.road_bearing);
        }
        
        // Function to create and display the map
        function displayMap(lat, lon, roadBearing) {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.style.display = 'block';
            
            // Store current data
            currentAddress = document.getElementById('address').value;
            currentCoordinates = { lat, lon };
            originalBearing = roadBearing;
            currentBearing = roadBearing;
            originalZoom = 18;
            
            // Update bearing display
            document.getElementById('bearingValue').textContent = `${roadBearing.toFixed(1)}¬∞`;
            
            // Initialize map if it doesn't exist
            if (!map) {
                map = L.map('map', {
                    minZoom: 16,
                    maxZoom: 18
                }).setView([lat, lon], originalZoom);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
                
                arrowManager = new ArrowManager(map);
                
                // Add event listeners for map interaction
                map.on('mousedown', onMapMouseDown);
                map.on('mousemove', onMapMouseMove);
                map.on('mouseup', onMapMouseUp);
            } else {
                map.setView([lat, lon], originalZoom);
                map.eachLayer((layer) => {
                    if (layer instanceof L.Marker || layer instanceof L.Polyline || layer instanceof L.Circle) {
                        map.removeLayer(layer);
                    }
                });
            }
            
            // Add marker for the address
            marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'address-marker',
                    html: '<svg width="24" height="36" viewBox="0 0 24 36" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.383 0 0 5.383 0 12c0 9 12 24 12 24s12-15 12-24c0-6.617-5.383-12-12-12zm0 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z" fill="#2A2B2A"/></svg>',
                    iconSize: [24, 36],
                    iconAnchor: [12, 36]
                })
            }).addTo(map);
            
            // Create interactive arrow
            arrowManager.createArrow(lat, lon, roadBearing, { interactive: true });
            isInteractiveMode = true;
            isDragging = false;
        }

        // Mouse event handlers for arrow interaction
        function onMapMouseDown(e) {
            if (!arrowManager || !arrowManager.arrowGroup || !arrowManager.isInteractive) return;
            
            const handleLatLng = arrowManager.arrowGroup.handle.getLatLng();
            const distance = map.distance(e.latlng, handleLatLng);
            
            if (distance < 80) {
                isDragging = true;
                document.body.classList.add('grabbing');
                
                // Remove handle during dragging
                map.removeLayer(arrowManager.arrowGroup.handle);
                arrowManager.arrowGroup.handle = null;
                
                e.originalEvent.stopPropagation();
                e.originalEvent.preventDefault();
                map.dragging.disable();
            }
        }
        
        function onMapMouseMove(e) {
            if (!isDragging || !arrowManager || !arrowManager.arrowGroup) return;
            
            e.originalEvent.stopPropagation();
            e.originalEvent.preventDefault();
            
            const [centerLat, centerLon] = arrowManager.arrowGroup.center;
            const mouseLat = e.latlng.lat;
            const mouseLon = e.latlng.lng;
            
            const start = [centerLon, centerLat];
            const end = [mouseLon, mouseLat];
            
            const bearing = (turf.bearing(start, end) + 360) % 360;
            
            currentBearing = bearing;
            arrowManager.updateArrow(currentBearing, false);
            document.getElementById('bearingValue').textContent = `${bearing.toFixed(1)}¬∞`;
        }
        
        function onMapMouseUp() {
            if (isDragging && arrowManager && arrowManager.arrowGroup) {
                isDragging = false;
                document.body.classList.remove('grabbing');
                
                // Recreate handle
                const [lat, lon] = arrowManager.arrowGroup.center;
                const start = [lon, lat];
                const destination = turf.destination(start, arrowManager.arrowGroup.length, currentBearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];
                
                arrowManager.arrowGroup.handle = L.marker([endLat, endLon], {
                    icon: L.divIcon({
                        className: 'arrow-handle',
                        html: '<div style="background-color: #2A2B2A; width: 24px; height: 24px; border-radius: 50%; border: 3px solid #fff; cursor: grab;"></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map);
                
                map.dragging.enable();
            }
        }

        // Calculate henge function
        async function calculateHenge() {
            const calculateBtn = document.getElementById('calculateHengeBtn');
            const loading = document.getElementById('loading');
            const hengeResult = document.getElementById('hengeResult');
            
            calculateBtn.disabled = true;
            loading.style.display = 'block';
            hengeResult.style.display = 'none';
            
            try {
                const response = await fetch('/lookup_address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        address: currentAddress,
                        road_bearing: currentBearing
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    displayResult(data);
                    
                    // Replace interactive arrow with static arrows
                    if (data.result.henge_found) {
                        arrowManager.clear();
                        arrowManager.createArrow(currentCoordinates.lat, currentCoordinates.lon, data.road_bearing);
                        arrowManager.addSunArrow(currentCoordinates.lat, currentCoordinates.lon, data.result.sun_angle);
                        
                        // Update map legend
                        document.querySelector('.map-info').innerHTML = 
                            '<strong>Map Legend:</strong> Dark arrow shows road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>. Orange arrow shows sun <span class="tooltip-term">azimuth<span class="tooltip">Angle of a celestial object (e.g. the sun) measured clockwise from True North</span></span>.';
                    } else {
                        arrowManager.clear();
                        arrowManager.createArrow(currentCoordinates.lat, currentCoordinates.lon, data.road_bearing);
                        
                        document.querySelector('.map-info').innerHTML = 
                            '<strong>Map Legend:</strong> Dark arrow shows road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>.';
                    }
                    
                    // Hide interactive elements
                    hideInteractiveElements();
                } else {
                    displayError(data.error);
                }
            } catch (error) {
                displayError('Network error. Please try again.');
            } finally {
                calculateBtn.disabled = false;
                loading.style.display = 'none';
            }
        }

        function hideInteractiveElements() {
            const calculateBtn = document.getElementById('calculateHengeBtn');
            const bearingControls = document.querySelector('.bearing-controls');
            const step2Header = document.querySelector('.map-container h3');
            const step3Header = document.querySelector('.main-action h3');
            
            calculateBtn.style.display = 'none';
            if (bearingControls) bearingControls.style.display = 'none';
            if (step2Header) step2Header.style.display = 'none';
            if (step3Header) step3Header.style.display = 'none';
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('calculateHengeBtn').addEventListener('click', calculateHenge);
            
            document.getElementById('resetBtn').addEventListener('click', function() {
                currentBearing = originalBearing;
                arrowManager.updateArrow(originalBearing);
                document.getElementById('bearingValue').textContent = `${originalBearing.toFixed(1)}¬∞`;
                
                // Reset zoom level to original
                if (map && currentCoordinates) {
                    map.setView([currentCoordinates.lat, currentCoordinates.lon], originalZoom);
                }
            });
        });

        // Form submission
        document.getElementById('hengeForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const address = document.getElementById('address').value;
            const submitBtn = document.getElementById('submitBtn');
            const loading = document.getElementById('loading');
            const addressResult = document.getElementById('addressResult');
            const hengeResult = document.getElementById('hengeResult');
            
            resetToInitialState();
            
            submitBtn.disabled = true;
            loading.style.display = 'block';
            addressResult.style.display = 'none';
            hengeResult.style.display = 'none';
            document.getElementById('mapContainer').style.display = 'none';
            
            try {
                const response = await fetch('/lookup_address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ address: address })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    displayAddressLookup(data);
                } else {
                    displayError(data.error, 'addressResult');
                }
            } catch (error) {
                console.error('Error:', error);
                displayError('Network error. Please try again.', 'addressResult');
            } finally {
                submitBtn.disabled = false;
                loading.style.display = 'none';
            }
        });

        function displayResult(data) {
            const hengeResultDiv = document.getElementById('hengeResult');
            const result = data.result;
            
            let html = '';
            
            if (result.henge_found) {
                html = `
                    <h3>üéâ Henge Found!</h3>
                    <p><span class="highlight">Next Henge Date:</span> ${result.henge_time_local_str ? result.henge_time_local_str : formatDate(result.henge_date)}</p>
                    <p><span class="highlight">Street <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span> ${data.road_bearing}¬∞ from North</p>
                    <p><span class="highlight">Sun <span class="tooltip-term">Azimuth<span class="tooltip">Angle of a celestial object (e.g. the sun) measured clockwise from True North</span></span>:</span> ${result.sun_angle}¬∞ from North</p>
                    <p><em>Perfect alignment! The sun will set directly down your street on this date.</em></p>
                    <div class="disclaimer">
                        <p><span class="topic">Note: These predictions are rough estimates calculations.</span> For official city-wide henge events (like Manhattanhenge), check official announcements. They use specific city reference points and spatial assumptions, which may differ from the street-to-street calculations and assumptions used here.</p>
                    </div>
                `;
                hengeResultDiv.className = 'result success';
            } else {
                html = `
                    <h3>üîç No Henge Found</h3>
                    <p><span class="highlight">Street <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span> ${data.road_bearing}¬∞ from North</p>
                    <p><em>No henge alignment found in the next ${result.days_searched} days. The sun's path doesn't align with your street's orientation at this location.</em></p>
                    <div class="disclaimer">
                        <p><span class="topic">Note: These predictions are rough calculations based on various assumptions.</span> For official city-wide henge events (like Manhattanhenge), check official announcements as they use specific reference points and may differ from street-to-street calculations here.</p>
                    </div>
                `;
                hengeResultDiv.className = 'result no-henge';
            }
            
            hengeResultDiv.innerHTML = html;
            hengeResultDiv.style.display = 'block';
        }

        function displayError(message, container = 'hengeResult') {
            const errorDiv = document.getElementById(container);
            
            errorDiv.innerHTML = `
                <h3>‚ùå Error</h3>
                <p>${message}</p>
            `;
            errorDiv.className = 'result error';
            errorDiv.style.display = 'block';
            
            // Hide other containers if showing address error
            if (container === 'addressResult') {
                document.getElementById('mapContainer').style.display = 'none';
                document.getElementById('hengeResult').style.display = 'none';
            }
        }

        function resetToInitialState() {
            if (arrowManager) {
                arrowManager.clear();
            }
            
            currentAddress = null;
            currentCoordinates = null;
            originalBearing = 0;
            currentBearing = 0;
            originalZoom = 18;
            isInteractiveMode = false;
            isDragging = false;
            
            // Show all interactive elements again
            const bearingControls = document.querySelector('.bearing-controls');
            if (bearingControls) bearingControls.style.display = 'flex';
            
            const bearingValue = document.getElementById('bearingValue');
            if (bearingValue) {
                bearingValue.style.display = 'inline';
                bearingValue.textContent = '0¬∞';
            }
            
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.style.display = 'inline-block';
            
            const calculateBtn = document.getElementById('calculateHengeBtn');
            if (calculateBtn) calculateBtn.style.display = 'block';
            
            const step2Header = document.querySelector('.map-container h3');
            if (step2Header) step2Header.style.display = 'block';
            
            const step3Header = document.querySelector('.main-action h3');
            if (step3Header) step3Header.style.display = 'block';
            
            document.querySelector('.map-info').innerHTML = 
                '<strong>Map Legend:</strong> Dark arrow shows the road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span> direction (drag to adjust).';
            
            if (map) {
                map.dragging.enable();
            }
        }
        
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Tab switching functionality
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');

            // Initialize solar system if switching to learn tab
            if (tabName === 'learn' && !window.solarSystemInitialized) {
                initSolarSystem();
                window.solarSystemInitialized = true;
            }
        }

        // Solar System Visualization
        let solarScene, solarRenderer, solarCamera;
        let sun, earth, earthGroup;
        let animationId;
        let isPlaying = false;
        let currentDay = 0;

        function initSolarSystem() {
            const canvas = document.getElementById('solarSystemCanvas');
            if (!canvas) return;

            // Scene setup
            solarScene = new THREE.Scene();
            solarCamera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            solarRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            solarRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
            solarRenderer.shadowMap.enabled = true;
            solarRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            solarScene.add(ambientLight);

            // Sun (point light source)
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                emissive: 0xffaa00,
                emissiveIntensity: 0.8
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            solarScene.add(sun);

            // Sun light
            const sunLight = new THREE.PointLight(0xffffff, 2, 100);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            solarScene.add(sunLight);

            // Earth group (for orbital motion)
            earthGroup = new THREE.Group();
            solarScene.add(earthGroup);

            // Earth
            const earthGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            
            // Custom shader material for day/night terminator
            const earthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    sunPosition: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 sunPosition;
                    varying vec3 vWorldPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        // Direction from earth surface to sun
                        vec3 sunDirection = normalize(sunPosition - vWorldPosition);
                        
                        // Simple day/night based on whether surface faces sun
                        float sunAlignment = dot(vNormal, sunDirection);
                        
                        // Sharp terminator line
                        float lightIntensity = step(0.0, sunAlignment);
                        
                        // Earth colors
                        vec3 dayColor = vec3(0.3, 0.7, 0.9);   // Bright blue
                        vec3 nightColor = vec3(0.05, 0.05, 0.15); // Dark blue
                        
                        vec3 finalColor = mix(nightColor, dayColor, lightIntensity);
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.position.set(8, 0, 0); // Distance from sun
            
            // Create equator ring (shows axial tilt) - make it more visible
            const equatorGeometry = new THREE.RingGeometry(0.82, 0.91, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95
            });
            const equatorRing = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equatorRing.rotation.x = Math.PI / 2; // Make it horizontal initially
            
            // Add a second, slightly larger ring for better visibility
            const equatorGeometry2 = new THREE.RingGeometry(0.80, 0.93, 64);
            const equatorMaterial2 = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4
            });
            const equatorRing2 = new THREE.Mesh(equatorGeometry2, equatorMaterial2);
            equatorRing2.rotation.x = Math.PI / 2;
            
            // Tilt the equator by 30 degrees to show Earth's axial tilt (more pronounced)
            const tiltAngle = THREE.MathUtils.degToRad(30);
            equatorRing.rotation.z = tiltAngle;
            equatorRing2.rotation.z = tiltAngle;
            
            earth.add(equatorRing);
            earth.add(equatorRing2);
            earthGroup.add(earth);

            // Camera position
            solarCamera.position.set(0, 8, 12);
            solarCamera.lookAt(0, 0, 0);

            // Controls
            setupSolarSystemControls();
            
            // Start animation
            animate();
        }

        function setupSolarSystemControls() {
            const timeSlider = document.getElementById('timeSlider');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const timeDisplay = document.getElementById('timeDisplay');
            const equinoxIndicator = document.getElementById('equinoxIndicator');

            if (!timeSlider || !playPauseBtn) return;

            timeSlider.addEventListener('input', (e) => {
                currentDay = parseInt(e.target.value);
                updateSolarSystem();
                updateTimeDisplay();
            });

            playPauseBtn.addEventListener('click', () => {
                isPlaying = !isPlaying;
                playPauseBtn.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            });

            function updateTimeDisplay() {
                const month = Math.floor(currentDay / 30.44) + 1;
                const dayOfMonth = Math.floor((currentDay % 30.44)) + 1;
                timeDisplay.textContent = `Day ${currentDay + 1} of Year (Month ${month}, Day ${dayOfMonth})`;
                
                // Check for equinoxes (around day 79 and 266)
                const isEquinox = (currentDay >= 78 && currentDay <= 82) || (currentDay >= 264 && currentDay <= 268);
                if (isEquinox) {
                    equinoxIndicator.classList.add('visible');
                } else {
                    equinoxIndicator.classList.remove('visible');
                }
            }

            updateTimeDisplay();
        }

        function updateSolarSystem() {
            if (!earthGroup || !earth) return;

            // Earth orbital position (365 days = full circle)
            const orbitalAngle = (currentDay / 365) * Math.PI * 2;
            earthGroup.rotation.y = orbitalAngle;

            // Earth rotation (daily spin) - only for visual effect
            earth.rotation.y = (currentDay * 5) * Math.PI / 180; // Slower rotation for better visibility

            // Update shader uniforms for day/night terminator
            // The sun is always at (0,0,0), so we need the earth's world position
            const earthWorldPosition = new THREE.Vector3();
            earth.getWorldPosition(earthWorldPosition);
            
            if (earth.material.uniforms) {
                // Sun position in world coordinates (always at origin)
                earth.material.uniforms.sunPosition.value.set(0, 0, 0);
            }

            // Update time slider
            const timeSlider = document.getElementById('timeSlider');
            if (timeSlider) {
                timeSlider.value = currentDay;
            }
        }

        function animate() {
            if (!solarRenderer || !solarScene || !solarCamera) return;

            animationId = requestAnimationFrame(animate);

            // Auto-advance time if playing
            if (isPlaying) {
                currentDay = (currentDay + 1) % 365;
                updateSolarSystem();
                
                const timeDisplay = document.getElementById('timeDisplay');
                const equinoxIndicator = document.getElementById('equinoxIndicator');
                
                if (timeDisplay) {
                    const month = Math.floor(currentDay / 30.44) + 1;
                    const dayOfMonth = Math.floor((currentDay % 30.44)) + 1;
                    timeDisplay.textContent = `Day ${currentDay + 1} of Year (Month ${month}, Day ${dayOfMonth})`;
                    
                    // Check for equinoxes (around day 79 and 266)
                    const isEquinox = (currentDay >= 78 && currentDay <= 82) || (currentDay >= 264 && currentDay <= 268);
                    if (equinoxIndicator) {
                        if (isEquinox) {
                            equinoxIndicator.classList.add('visible');
                        } else {
                            equinoxIndicator.classList.remove('visible');
                        }
                    }
                }
            }

            // Continuous earth rotation for visual effect (much slower)
            if (earth) {
                earth.rotation.y += 0.002;
            }

            solarRenderer.render(solarScene, solarCamera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (solarRenderer && solarCamera) {
                const canvas = document.getElementById('solarSystemCanvas');
                if (canvas) {
                    solarCamera.aspect = canvas.clientWidth / canvas.clientHeight;
                    solarCamera.updateProjectionMatrix();
                    solarRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
                }
            }
        });

        // Street Henge Visualization
        let streetCanvas, streetCtx;
        let currentTimeMinutes = 120; // Start at 6:00 PM (4PM + 120 minutes)
        const MANHATTAN_BEARING = 299; // Manhattan street bearing
        let streetAnimationInitialized = false;

        function initStreetVisualization() {
            streetCanvas = document.getElementById('streetHengeCanvas');
            if (!streetCanvas) return;
            
            streetCtx = streetCanvas.getContext('2d');
            streetCanvas.width = streetCanvas.clientWidth;
            streetCanvas.height = streetCanvas.clientHeight;
            
            setupStreetControls();
            updateStreetScene();
            streetAnimationInitialized = true;
        }

        function setupStreetControls() {
            const timeSlider = document.getElementById('streetTimeSlider');
            const timeDisplay = document.getElementById('streetTimeDisplay');
            
            if (!timeSlider || !timeDisplay) return;
            
            timeSlider.addEventListener('input', (e) => {
                currentTimeMinutes = parseInt(e.target.value);
                updateTimeDisplay();
                updateStreetScene();
            });
            
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const timeDisplay = document.getElementById('streetTimeDisplay');
            if (!timeDisplay) return;
            
            // Convert minutes since 4 PM to actual time
            const startHour = 16; // 4 PM
            const totalMinutes = currentTimeMinutes;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            const actualHour = startHour + hours;
            
            const displayHour = actualHour > 12 ? actualHour - 12 : actualHour;
            const ampm = actualHour >= 12 ? 'PM' : 'AM';
            const timeString = `${displayHour}:${minutes.toString().padStart(2, '0')} ${ampm}`;
            
            timeDisplay.textContent = timeString;
        }

        function updateStreetScene() {
            if (!streetCtx || !streetCanvas) return;
            
            // Get current time for API call
            const now = new Date();
            const startHour = 16; // 4 PM
            const hours = Math.floor(currentTimeMinutes / 60);
            const minutes = currentTimeMinutes % 60;
            const targetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), startHour + hours, minutes);
            
            // Call API to get sun position
            fetch('/lookup_azimuth_altitude', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    time: targetTime.toISOString(),
                    road_bearing: MANHATTAN_BEARING
                })
            })
            .then(response => response.json())
            .then(data => {
                drawStreetScene(data.graphic_az, data.altitude);
            })
            .catch(error => {
                console.error('Error fetching sun position:', error);
                // Draw scene with default values if API fails
                drawStreetScene(0, 5);
            });
        }

        function drawStreetScene(graphicAz, altitude) {
            if (!streetCtx || !streetCanvas) return;
            
            const width = streetCanvas.width;
            const height = streetCanvas.height;
            
            // Clear canvas
            streetCtx.clearRect(0, 0, width, height);
            
            // Draw sky gradient
            const gradient = streetCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.3, '#FFE4B5'); // Moccasin
            gradient.addColorStop(0.7, '#FFA07A'); // Light salmon
            gradient.addColorStop(1, '#FF6347'); // Tomato
            
            streetCtx.fillStyle = gradient;
            streetCtx.fillRect(0, 0, width, height);
            
            // Draw street (perspective view)
            const streetWidth = width * 0.8;
            const streetStartY = height * 0.8;
            const vanishingPointX = width / 2;
            const vanishingPointY = height * 0.4;
            
            // Street surface
            streetCtx.fillStyle = '#666';
            streetCtx.beginPath();
            streetCtx.moveTo((width - streetWidth) / 2, streetStartY);
            streetCtx.lineTo((width + streetWidth) / 2, streetStartY);
            streetCtx.lineTo(vanishingPointX + 20, vanishingPointY);
            streetCtx.lineTo(vanishingPointX - 20, vanishingPointY);
            streetCtx.closePath();
            streetCtx.fill();
            
            // Draw buildings on both sides
            drawBuildings(width, height, vanishingPointX, vanishingPointY, streetWidth, streetStartY);
            
            // Draw sun
            drawSun(graphicAz, altitude, width, height, vanishingPointX, vanishingPointY);
            
            // Check if it's a henge (sun aligned with street)
            const hengeIndicator = document.getElementById('hengeIndicator');
            if (hengeIndicator) {
                if (Math.abs(graphicAz) < 5 && altitude > 0) { // Close to alignment
                    hengeIndicator.classList.add('visible');
                } else {
                    hengeIndicator.classList.remove('visible');
                }
            }
        }

        function drawBuildings(width, height, vanishingPointX, vanishingPointY, streetWidth, streetStartY) {
            const buildingColor = '#444';
            const windowColor = '#FFD700';
            
            // Left side buildings
            for (let i = 0; i < 4; i++) {
                const buildingStartX = (width - streetWidth) / 2 - 50 - i * 20;
                const buildingEndX = buildingStartX - 60 + i * 10;
                const buildingHeight = 100 + i * 20;
                
                // Building face
                streetCtx.fillStyle = buildingColor;
                streetCtx.beginPath();
                streetCtx.moveTo(buildingStartX, streetStartY);
                streetCtx.lineTo(buildingStartX, streetStartY - buildingHeight);
                streetCtx.lineTo(vanishingPointX - 40 - i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.lineTo(vanishingPointX - 40 - i * 15, vanishingPointY);
                streetCtx.closePath();
                streetCtx.fill();
                
                // Side face
                streetCtx.fillStyle = '#333';
                streetCtx.beginPath();
                streetCtx.moveTo(buildingStartX, streetStartY - buildingHeight);
                streetCtx.lineTo(buildingEndX, streetStartY - buildingHeight);
                streetCtx.lineTo(vanishingPointX - 50 - i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.lineTo(vanishingPointX - 40 - i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.closePath();
                streetCtx.fill();
                
                // Windows
                drawBuildingWindows(buildingStartX - 10, streetStartY - buildingHeight + 20, 3, 4, windowColor);
            }
            
            // Right side buildings
            for (let i = 0; i < 4; i++) {
                const buildingStartX = (width + streetWidth) / 2 + 50 + i * 20;
                const buildingEndX = buildingStartX + 60 - i * 10;
                const buildingHeight = 100 + i * 20;
                
                // Building face
                streetCtx.fillStyle = buildingColor;
                streetCtx.beginPath();
                streetCtx.moveTo(buildingStartX, streetStartY);
                streetCtx.lineTo(buildingStartX, streetStartY - buildingHeight);
                streetCtx.lineTo(vanishingPointX + 40 + i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.lineTo(vanishingPointX + 40 + i * 15, vanishingPointY);
                streetCtx.closePath();
                streetCtx.fill();
                
                // Side face
                streetCtx.fillStyle = '#333';
                streetCtx.beginPath();
                streetCtx.moveTo(buildingStartX, streetStartY - buildingHeight);
                streetCtx.lineTo(buildingEndX, streetStartY - buildingHeight);
                streetCtx.lineTo(vanishingPointX + 50 + i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.lineTo(vanishingPointX + 40 + i * 15, vanishingPointY - buildingHeight * 0.3);
                streetCtx.closePath();
                streetCtx.fill();
                
                // Windows
                drawBuildingWindows(buildingStartX + 10, streetStartY - buildingHeight + 20, 3, 4, windowColor);
            }
        }

        function drawBuildingWindows(x, y, rows, cols, color) {
            streetCtx.fillStyle = color;
            const windowWidth = 8;
            const windowHeight = 12;
            const spacingX = 15;
            const spacingY = 20;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    streetCtx.fillRect(
                        x + col * spacingX,
                        y + row * spacingY,
                        windowWidth,
                        windowHeight
                    );
                }
            }
        }

        function drawSun(graphicAz, altitude, width, height, vanishingPointX, vanishingPointY) {
            if (altitude <= 0) return; // Sun is below horizon
            
            // Convert graphic azimuth to screen position
            // graphicAz = 0 means perfectly aligned with street
            // Negative values = sun is to the left, positive = to the right
            const sunX = vanishingPointX + (graphicAz * 3); // Scale the azimuth for visual effect
            const sunY = vanishingPointY - (altitude * 8); // Higher altitude = higher on screen
            
            // Ensure sun stays within reasonable bounds
            const clampedSunX = Math.max(50, Math.min(width - 50, sunX));
            const clampedSunY = Math.max(50, Math.min(height * 0.8, sunY));
            
            // Draw sun
            const sunRadius = 25;
            const sunGradient = streetCtx.createRadialGradient(clampedSunX, clampedSunY, 0, clampedSunX, clampedSunY, sunRadius);
            sunGradient.addColorStop(0, '#FFF');
            sunGradient.addColorStop(0.3, '#FFFF99');
            sunGradient.addColorStop(1, '#FFD700');
            
            streetCtx.fillStyle = sunGradient;
            streetCtx.beginPath();
            streetCtx.arc(clampedSunX, clampedSunY, sunRadius, 0, Math.PI * 2);
            streetCtx.fill();
            
            // Draw sun rays
            streetCtx.strokeStyle = '#FFFF99';
            streetCtx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                const rayLength = 15;
                streetCtx.beginPath();
                streetCtx.moveTo(
                    clampedSunX + Math.cos(angle) * (sunRadius + 5),
                    clampedSunY + Math.sin(angle) * (sunRadius + 5)
                );
                streetCtx.lineTo(
                    clampedSunX + Math.cos(angle) * (sunRadius + rayLength),
                    clampedSunY + Math.sin(angle) * (sunRadius + rayLength)
                );
                streetCtx.stroke();
            }
        }

        // Orbital Visualization Variables
        let orbitalCanvas, orbitalCtx, tiltCanvas, tiltCtx;
        let orbitalCurrentDay = 0;
        let orbitalAnimationInitialized = false;

        function initOrbitalVisualization() {
            orbitalCanvas = document.getElementById('orbitalCanvas');
            tiltCanvas = document.getElementById('tiltCanvas');
            
            if (!orbitalCanvas || !tiltCanvas) return;
            
            orbitalCtx = orbitalCanvas.getContext('2d');
            tiltCtx = tiltCanvas.getContext('2d');
            
            // Set canvas dimensions
            orbitalCanvas.width = orbitalCanvas.clientWidth;
            orbitalCanvas.height = orbitalCanvas.clientHeight;
            tiltCanvas.width = tiltCanvas.clientWidth;
            tiltCanvas.height = tiltCanvas.clientHeight;
            
            setupOrbitalControls();
            updateOrbitalVisualization();
            orbitalAnimationInitialized = true;
        }

        function setupOrbitalControls() {
            const timeSlider = document.getElementById('orbitalTimeSlider');
            const timeDisplay = document.getElementById('orbitalTimeDisplay');
            const equinoxIndicator = document.getElementById('orbitalEquinoxIndicator');
            
            if (!timeSlider || !timeDisplay) return;
            
            timeSlider.addEventListener('input', (e) => {
                orbitalCurrentDay = parseInt(e.target.value);
                updateOrbitalTimeDisplay();
                updateOrbitalVisualization();
            });
            
            updateOrbitalTimeDisplay();
        }

        function updateOrbitalTimeDisplay() {
            const timeDisplay = document.getElementById('orbitalTimeDisplay');
            const equinoxIndicator = document.getElementById('orbitalEquinoxIndicator');
            if (!timeDisplay) return;
            
            // Calculate month and day
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            let remainingDays = orbitalCurrentDay;
            let month = 0;
            let day = 1;
            
            for (let i = 0; i < 12; i++) {
                if (remainingDays < daysInMonth[i]) {
                    month = i;
                    day = remainingDays + 1;
                    break;
                }
                remainingDays -= daysInMonth[i];
            }
            
            timeDisplay.textContent = `Day ${orbitalCurrentDay + 1} of Year (${monthNames[month]} ${day})`;
            
            // Check for equinoxes and solstices
            if (equinoxIndicator) {
                const isEquinox = (orbitalCurrentDay >= 79 && orbitalCurrentDay <= 83) || // Spring equinox
                                 (orbitalCurrentDay >= 265 && orbitalCurrentDay <= 269); // Fall equinox
                if (isEquinox) {
                    equinoxIndicator.classList.add('visible');
                    equinoxIndicator.style.opacity = '1';
                } else {
                    equinoxIndicator.classList.remove('visible');
                    equinoxIndicator.style.opacity = '0';
                }
            }
        }

        function updateOrbitalVisualization() {
            drawOrbitalView();
            drawTiltView();
        }

        function drawOrbitalView() {
            if (!orbitalCtx || !orbitalCanvas) return;
            
            const width = orbitalCanvas.width;
            const height = orbitalCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Clear canvas
            orbitalCtx.clearRect(0, 0, width, height);
            
            // Draw orbital path
            orbitalCtx.strokeStyle = '#444';
            orbitalCtx.lineWidth = 2;
            orbitalCtx.beginPath();
            orbitalCtx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            orbitalCtx.stroke();
            
            // Draw Sun at center
            const sunGradient = orbitalCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 15);
            sunGradient.addColorStop(0, '#FFF');
            sunGradient.addColorStop(0.3, '#FFFF99');
            sunGradient.addColorStop(1, '#FFD700');
            
            orbitalCtx.fillStyle = sunGradient;
            orbitalCtx.beginPath();
            orbitalCtx.arc(centerX, centerY, 15, 0, Math.PI * 2);
            orbitalCtx.fill();
            
            // Add sun label
            orbitalCtx.fillStyle = '#FFF';
            orbitalCtx.font = '12px Arial';
            orbitalCtx.textAlign = 'center';
            orbitalCtx.fillText('Sun', centerX, centerY + 35);
            
            // Calculate Earth position based on day of year
            const angle = (orbitalCurrentDay / 365) * Math.PI * 2 - Math.PI / 2; // Start from top
            const earthX = centerX + Math.cos(angle) * 80;
            const earthY = centerY + Math.sin(angle) * 80;
            
            // Draw Earth
            const earthGradient = orbitalCtx.createRadialGradient(earthX, earthY, 0, earthX, earthY, 8);
            earthGradient.addColorStop(0, '#6B9BD2');
            earthGradient.addColorStop(1, '#4A7BA7');
            
            orbitalCtx.fillStyle = earthGradient;
            orbitalCtx.beginPath();
            orbitalCtx.arc(earthX, earthY, 8, 0, Math.PI * 2);
            orbitalCtx.fill();
            
            // Draw Earth's rotational axis (to show tilt isn't visible from top)
            orbitalCtx.strokeStyle = '#90EE90';
            orbitalCtx.lineWidth = 2;
            orbitalCtx.beginPath();
            orbitalCtx.moveTo(earthX, earthY - 12);
            orbitalCtx.lineTo(earthX, earthY + 12);
            orbitalCtx.stroke();
            
            // Add Earth label
            orbitalCtx.fillStyle = '#FFF';
            orbitalCtx.font = '12px Arial';
            orbitalCtx.textAlign = 'center';
            orbitalCtx.fillText('Earth', earthX, earthY + 25);
            
            // Add directional labels
            orbitalCtx.fillStyle = '#CCC';
            orbitalCtx.font = '14px Arial';
            orbitalCtx.textAlign = 'center';
            orbitalCtx.fillText('Summer Solstice', centerX, centerY - 110);
            orbitalCtx.fillText('Winter Solstice', centerX, centerY + 125);
            
            orbitalCtx.textAlign = 'left';
            orbitalCtx.fillText('Spring Equinox', centerX + 90, centerY + 5);
            orbitalCtx.textAlign = 'right';
            orbitalCtx.fillText('Fall Equinox', centerX - 90, centerY + 5);
        }

        function drawTiltView() {
            if (!tiltCtx || !tiltCanvas) return;
            
            const width = tiltCanvas.width;
            const height = tiltCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Clear canvas
            tiltCtx.clearRect(0, 0, width, height);
            
            // Draw Sun on the left
            const sunGradient = tiltCtx.createRadialGradient(50, centerY, 0, 50, centerY, 20);
            sunGradient.addColorStop(0, '#FFF');
            sunGradient.addColorStop(0.3, '#FFFF99');
            sunGradient.addColorStop(1, '#FFD700');
            
            tiltCtx.fillStyle = sunGradient;
            tiltCtx.beginPath();
            tiltCtx.arc(50, centerY, 20, 0, Math.PI * 2);
            tiltCtx.fill();
            
            // Add sun label
            tiltCtx.fillStyle = '#FFF';
            tiltCtx.font = '12px Arial';
            tiltCtx.textAlign = 'center';
            tiltCtx.fillText('Sun', 50, centerY + 40);
            
            // Draw Earth
            const earthGradient = tiltCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            earthGradient.addColorStop(0, '#6B9BD2');
            earthGradient.addColorStop(1, '#4A7BA7');
            
            tiltCtx.fillStyle = earthGradient;
            tiltCtx.beginPath();
            tiltCtx.arc(centerX, centerY, 25, 0, Math.PI * 2);
            tiltCtx.fill();
            
            // Calculate tilt angle based on day of year
            // 23.5 degrees maximum tilt, varies with season
            const axisLength = 40;
            const seasonalAngle = (orbitalCurrentDay / 365) * Math.PI * 2;
            const maxX = Math.sin(23.5 * Math.PI / 180) * axisLength; // max the pole will move on the X axis
            const offsetY = Math.cos(23.5 * Math.PI / 180) * axisLength; // half the height of our pole line on the Y axis
            // const tiltDegrees = 23.5 * Math.sin(seasonalAngle);
            //const tiltRadians = (tiltDegrees * Math.PI) / 180;
            
            // Draw rotational axis showing tilt
            const axisEndX = centerX + Math.sin(seasonalAngle) * maxX;
            const axisEndY = centerY - offsetY;
            const axisStartX = centerX - Math.sin(seasonalAngle) * maxX;
            const axisStartY = centerY + offsetY;
            
            tiltCtx.strokeStyle = '#90EE90';
            tiltCtx.lineWidth = 3;
            tiltCtx.beginPath();
            tiltCtx.moveTo(axisStartX, axisStartY);
            tiltCtx.lineTo(axisEndX, axisEndY);
            tiltCtx.stroke();
            
            // Draw North Pole marker
            tiltCtx.fillStyle = '#FF6B6B';
            tiltCtx.beginPath();
            tiltCtx.arc(axisEndX, axisEndY, 5, 0, Math.PI * 2);
            tiltCtx.fill();
            
            // Add North Pole label
            tiltCtx.fillStyle = '#FFF';
            tiltCtx.font = '12px Arial';
            tiltCtx.textAlign = 'center';
            tiltCtx.fillText('North Pole', axisEndX, axisEndY - 15);
            
            // Draw South Pole marker
            tiltCtx.fillStyle = '#6B6BFF';
            tiltCtx.beginPath();
            tiltCtx.arc(axisStartX, axisStartY, 5, 0, Math.PI * 2);
            tiltCtx.fill();
            
            // Add South Pole label
            tiltCtx.fillText('South Pole', axisStartX, axisStartY + 25);
            
            // Add Earth label
            tiltCtx.fillText('Earth', centerX, centerY + 45);
            
            // Show tilt angle
            tiltCtx.fillStyle = '#FFFF99';
            tiltCtx.font = '14px Arial';
            tiltCtx.textAlign = 'center';
            tiltCtx.fillText(`Tilt: ${tiltDegrees.toFixed(1)}¬∞`, centerX, height - 20);
            
            // Draw reference line (vertical) to show tilt
            tiltCtx.strokeStyle = '#666';
            tiltCtx.lineWidth = 1;
            tiltCtx.setLineDash([5, 5]);
            tiltCtx.beginPath();
            tiltCtx.moveTo(centerX, centerY - 50);
            tiltCtx.lineTo(centerX, centerY + 50);
            tiltCtx.stroke();
            tiltCtx.setLineDash([]);
            
            // Add seasonal information
            let seasonText = '';
            if (orbitalCurrentDay >= 0 && orbitalCurrentDay < 79) {
                seasonText = 'Winter ‚Üí Spring';
            } else if (orbitalCurrentDay >= 79 && orbitalCurrentDay < 172) {
                seasonText = 'Spring ‚Üí Summer';
            } else if (orbitalCurrentDay >= 172 && orbitalCurrentDay < 265) {
                seasonText = 'Summer ‚Üí Fall';
            } else {
                seasonText = 'Fall ‚Üí Winter';
            }
            
            tiltCtx.fillStyle = '#CCC';
            tiltCtx.font = '12px Arial';
            tiltCtx.textAlign = 'center';
            tiltCtx.fillText(seasonText, centerX, 30);
        }

        // Update the showTab function to initialize all visualizations
        const originalShowTab = showTab;
        showTab = function(tabName) {
            originalShowTab.call(this, tabName);
            
            // Initialize visualizations if switching to learn tab
            if (tabName === 'learn') {
                if (!streetAnimationInitialized) {
                    setTimeout(() => {
                        initStreetVisualization();
                    }, 100);
                }
                if (!orbitalAnimationInitialized) {
                    setTimeout(() => {
                        initOrbitalVisualization();
                    }, 150);
                }
            }
        };

    </script>
</body>
</html> 