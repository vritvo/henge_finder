<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Henge Finder</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #5E4955;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.08);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #2A2B2A;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .instructions {
            background: #fff;
            border-left: 4px solid #978897;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
        }

        .instructions h3 {
            color: #5E4955;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .instructions p {
            color: #2A2B2A;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .instructions p:last-child {
            margin-bottom: 0;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #5E4955;
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
            background: #fff;
            color: #2A2B2A;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #5E4955;
        }

        button {
            width: 100%;
            padding: 15px;
            background: #5E4955;
            color: #fff3ec;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            background: #4f3d47;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            text-align: center;
            color: #2A2B2A;
            margin-top: 20px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #5E4955;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .result.success {
            background: #e7f7f0;
            border: 1px solid #b0e0d3;
            color: #2A2B2A;
            display: block;
        }

        .result.address {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            color: #2A2B2A;
            display: block;
        }

        .result.error {
            background: #fbe6ec;
            border: 1px solid #f5c6cb;
            color: #5E4955;
            display: block;
        }

        .result.no-henge {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            display: block;
        }

        .result h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
            color: #5E4955;
        }

        .result p {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .highlight {
            font-weight: 600;
            color: #996888;
        }

        .coordinates {
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            color: #2A2B2A;
        }

        .disclaimer {
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
            border-left: 3px solid #5E4955;
        }

        .disclaimer p {
            margin: 0;
            font-size: 0.9em;
            color: #2A2B2A;
            line-height: 1.4;
        }
        
        .disclaimer p:not(:last-child) {
            margin-bottom: 15px;
        }
        
        .disclaimer .topic {
            font-weight: 700;
            color: #5E4955;
            margin-bottom: 5px;
        }

        .map-container {
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #e1e5e9;
        }

        .step-instructions {
            background: #f8f9fa;
            padding: 15px;
            margin: 0 0 15px 0;
            border-left: 4px solid #DC816E;
            border-radius: 0 8px 8px 0;
        }

        .step-instructions p {
            margin: 0;
            color: #2A2B2A;
            line-height: 1.5;
            font-size: 0.95em;
        }

        #map {
            height: 500px;
            width: 100%;
            position: relative;
        }

        .compass-container {
            position: relative;
            padding: 0 30px;
        }

        .compass-marker {
            position: absolute;
            background: rgba(94, 73, 85, 0.9);
            color: white;
            font-weight: bold;
            font-size: 14px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .compass-north {
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-south {
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-east {
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-west {
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .map-info {
            background: #f8f9fa;
            padding: 10px;
            border-top: 1px solid #e1e5e9;
            font-size: 0.9em;
            color: #2A2B2A;
        }

        .bearing-controls {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #e1e5e9;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bearing-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bearing-value {
            font-weight: bold;
            color: #5E4955;
            font-size: 1.1em;
        }

        .bearing-buttons {
            display: flex;
            gap: 10px;
        }

        .bearing-btn {
            padding: 8px 12px;
            background: #5E4955;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .bearing-btn:hover {
            background: #4f3d47;
        }

        .bearing-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .reset-btn {
            background: #6c757d;
        }

        .reset-btn:hover {
            background: #5a6268;
        }

        .main-action {
            margin-top: 20px;
            text-align: center;
        }

        .main-btn {
            padding: 18px 30px;
            background: #5E4955;
            color: #fff3ec;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s;
            min-width: 200px;
        }

        .main-btn:hover {
            transform: translateY(-2px);
            background: #4f3d47;
        }

        .main-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .spinner-hint {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Interactive arrow styling */
        .interactive-arrow {
            cursor: grab;
            transition: opacity 0.2s;
        }

        .interactive-arrow:hover {
            opacity: 1 !important;
        }

        .arrow-handle {
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing !important;
        }

        body.grabbing .interactive-arrow,
        body.grabbing .arrow-handle {
            cursor: grabbing !important;
        }

        /* Toggle/Summary hover effects */
        summary:hover {
            background-color: #e9ecef !important;
        }

        /* Tooltip styles */
        .tooltip-term {
            color: #996888;
            text-decoration: underline;
            text-decoration-style: dotted;
            cursor: help;
            position: relative;
            font-weight: 600;
        }

        .tooltip-term:hover {
            color: #5E4955;
        }

        .tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #5E4955;
            color: #fff3ec;
            text-align: center;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: normal;
            line-height: 1.4;
            white-space: normal;
            width: 200px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: opacity 0.2s, visibility 0.2s;
        }

        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #5E4955 transparent transparent transparent;
        }

        .tooltip-term:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }


        /* Mobile block styles */
        .mobile-block {
            display: none;
            min-height: 100vh;
            background: #5E4955;
            color: #fff3ec;
            padding: 40px 20px;
            text-align: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .mobile-block h1 {
            color: #fff3ec;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .mobile-block p {
            font-size: 1.1em;
            line-height: 1.6;
            max-width: 400px;
            margin-bottom: 15px;
        }

        .mobile-block .icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.8;
        }

    </style>
</head>
<body>
    <!-- Mobile block message -->
    <div class="mobile-block" id="mobileBlock">
        <h1>Desktop Required</h1>
        <p>Henge Finder requires a desktop or laptop computer.</p>
        <p>Please visit this site on a desktop browser to find your street's henge alignment.</p>
    </div>

    <div class="container" id="mainContainer">
        <h1>Henge Finder</h1>
        
        <div class="instructions">
            <details>
                <summary style="cursor: pointer; color: #5E4955; font-weight: 600; margin-bottom: 10px; padding: 15px; border-radius: 8px; background: #f8f9fa; border: 1px solid #e1e5e9; transition: background-color 0.2s;">
                    <span style="font-size: 1.4em;">What is a henge?</span>
                </summary>
                <div style="display: flex; align-items: flex-start; gap: 20px; margin-top: 15px;">
                    <div style="flex: 1;">
                        <p style="color: #2A2B2A; line-height: 1.6; margin-bottom: 15px;">A 'henge' is when the sun sets perfectly in line with your street, creating a dramatic view ‚Äî like <a href="https://en.wikipedia.org/wiki/Manhattanhenge" target="_blank" style="color: #996888; text-decoration: none;">Manhattanhenge</a> in New York.</p>
                        <p style="color: #2A2B2A; line-height: 1.6; margin-bottom: 0;">Use this tool to find when the next henge will happen for your street.</p>
                    </div>
                    <div style="flex-shrink: 0; max-width: 300px;">
                        <img src="{{ url_for('static', filename='images/city_henge.png') }}" 
                             alt="Example of a street henge with the sun aligned down a city street" 
                             style="width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    </div>
                </div>
            </details>
        </div>

        <div class="instructions">
            <details>
                <summary style="cursor: pointer; color: #5E4955; font-weight: 600; margin-bottom: 10px; padding: 15px; border-radius: 8px; background: #f8f9fa; border: 1px solid #e1e5e9; transition: background-color 0.2s;">
                    <span style="font-size: 1.4em;">What makes a good street for a henge?</span>
                </summary>
                <p style="color: #2A2B2A; margin-bottom: 15px;"><em>(Tips for finding the best henge view)</em></p>
                <ul style="color: #2A2B2A; line-height: 1.6; margin-left: 20px; margin-bottom: 20px;">
                    <li><strong>Pick a long, straight road with a clear view of the horizon.</strong><br>
                    Henges work best when you can actually see the sun touch the horizon. Curvy streets won't align well, and wider streets tend to give better views.</li>
                    <li><strong>Aim for a mostly east‚Äìwest street.</strong><br>
                    The sun won't set along a north‚Äìsouth road. It doesn't have to be perfect ‚Äî the sunset shifts a little each day.</li>
                    <li><strong>Avoid entering an intersection address if possible.</strong><br>
                    It's not necessary for this to work, but it will be faster.</li>
                </ul>
                <p style="color: #2A2B2A; margin-bottom: 10px;"><strong>Example Streets:</strong></p>
                <ul style="color: #2A2B2A; line-height: 1.6; margin-left: 20px;">
                    <li><a href="https://www.google.com/maps/place/251+W+42nd+St,+New+York,+NY+10036/@40.7570115,-73.9893081,18z/data=!4m15!1m8!3m7!1s0x89c2585360bfe5e7:0xd3b373353146c43f!2s251+W+42nd+St,+New+York,+NY+10036!3b1!8m2!3d40.757119!4d-73.9891884!16s%2Fg%2F11nnknww84!3m5!1s0x89c2585360bfe5e7:0xd3b373353146c43f!8m2!3d40.757119!4d-73.9891884!16s%2Fg%2F11nnknww84?entry=ttu&g_ep=EgoyMDI1MDczMC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">251 W 42nd St, New York, NY</a>, by Times Square</li>
                    <li><a href="https://www.google.com/maps/place/601+E+76th+St,+Chicago,+IL+60619/@41.756679,-87.61279,17z/data=!3m1!4b1!4m5!3m4!1s0x880e28c816730d29:0x111671091e24efc4!8m2!3d41.756675!4d-87.6102151?entry=ttu&g_ep=EgoyMDI1MDczMC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">601-615 E 76th St, Chicago, IL</a></li>
                    <li><a href="https://www.google.com/maps/place/Haarlemmerweg+109-C,+1051+KV+Amsterdam,+Netherlands/@52.3853326,4.8733117,19z/data=!3m1!4b1!4m6!3m5!1s0x47c609d5b0e41589:0xf6191c1b666122c1!8m2!3d52.3853318!4d4.8739554!16s%2Fg%2F11nnkplcpz?entry=ttu&g_ep=EgoyMDI1MDgyNC4wIKXMDSoASAFQAw%3D%3D" target="_blank" style="color: #996888; text-decoration: none;">Haarlemmerweg 109-C, 1051 KV Amsterdam, Netherlands</a>, along the canal by the Wester Park</li>
                </ul>
            </details>
        </div>
        <form id="hengeForm">
            <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em;">Step 1: Enter an address</h3>
            <div class="form-group">
                <input type="text" id="address" name="address" placeholder="e.g., 251 W 42nd St, New York, NY 10036" required>
            </div>
            <button type="submit" id="submitBtn">Find Address</button>
        </form>

        <div class="loading" id="loading" style="display: none;">
            <div class="spinner"></div>
            <p>May take a second...</p>
        </div>

        <div class="result" id="addressResult"></div>
        
        <div class="map-container" id="mapContainer" style="display: none;">
            <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em;">Step 2: Adjust the arrow to match the street's direction</h3>
            <div class="step-instructions">
                <p>We've estimated your street's direction from map data. <strong>If the arrow aligns with your street, you're all set!</strong> If not, drag the arrow handle to match the street direction you want the henge for.</p>
            </div>
            <div class="compass-container">
                <div class="compass-marker compass-north">N</div>
                <div class="compass-marker compass-south">S</div>
                <div class="compass-marker compass-east">E</div>
                <div class="compass-marker compass-west">W</div>
                <div id="map"></div>
            </div>
            <div class="bearing-controls">
                <div class="bearing-info">
                    <span>Road <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span>
                    <span class="bearing-value" id="bearingValue">0¬∞</span>
                </div>
                <div class="bearing-buttons">
                    <button class="bearing-btn reset-btn" id="resetBtn">Reset to Original</button>
                </div>
            </div>
            <div class="map-info">
                <strong>Map Legend:</strong> Dark arrow shows the road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span> direction (drag to adjust).
            </div>
            <div class="main-action">
                <h3 style="color: #DC816E; margin-bottom: 15px; font-size: 1.3em; text-align: left;">Step 3: Find henge</h3>
                <button class="main-btn" id="calculateHengeBtn">Let's go!</button>
            </div>
        </div>

        <div class="result" id="hengeResult" style="display: none;"></div>
    </div>

    <script>
        // Mobile detection and blocking
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Check for mobile user agents - this catches phones, tablets, etc.
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            const isMobileUserAgent = mobileRegex.test(userAgent.toLowerCase());
            
            // Check for touch-only devices (but exclude desktop touch screens)
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const hasMouseSupport = window.matchMedia('(pointer: fine)').matches;
            const isTouchOnly = isTouchDevice && !hasMouseSupport;
            
            // Block if mobile user agent OR touch-only device (excludes desktop touch screens)
            return isMobileUserAgent || isTouchOnly;
        }

        function initializeApp() {
            if (isMobileDevice()) {
                // Show mobile block, hide main content
                document.getElementById('mobileBlock').style.display = 'flex';
                document.getElementById('mainContainer').style.display = 'none';
                return;
            }
            
            // Hide mobile block, show main content
            document.getElementById('mobileBlock').style.display = 'none';
            document.getElementById('mainContainer').style.display = 'block';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Re-check on window resize (in case user rotates device or resizes browser)
        window.addEventListener('resize', initializeApp);

        let map = null;
        let marker = null;
        let currentAddress = null;
        let currentCoordinates = null;
        let originalBearing = 0;
        let currentBearing = 0;
        let originalZoom = 18;
        let isInteractiveMode = false;
        let isDragging = false;

        // Unified arrow management
        class ArrowManager {
            constructor(map) {
                this.map = map;
                this.arrowGroup = null;
                this.isInteractive = false;
            }

            createArrow(lat, lon, bearing, options = {}) {
                const {
                    color = '#2A2B2A',
                    weight = 4,
                    opacity = 0.8,
                    length = 100,
                    interactive = false
                } = options;

                // Clear existing arrow
                this.clear();

                // Calculate arrow endpoint
                const start = [lon, lat];
                const destination = turf.destination(start, length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Create arrow line
                const arrowLine = L.polyline([[lat, lon], [endLat, endLon]], {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    className: interactive ? 'interactive-arrow' : ''
                });

                // Create arrowhead
                const arrowheadLines = this.createArrowhead(destination, bearing, color, weight, opacity);

                // Create handle if interactive
                let handle = null;
                if (interactive) {
                    handle = L.marker([endLat, endLon], {
                        icon: L.divIcon({
                            className: 'arrow-handle',
                            html: '<div style="background-color: #2A2B2A; width: 24px; height: 24px; border-radius: 50%; border: 3px solid #fff; cursor: grab;"></div>',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    });
                }

                // Group all elements
                this.arrowGroup = {
                    line: arrowLine,
                    arrowheads: arrowheadLines,
                    handle: handle,
                    center: [lat, lon],
                    bearing: bearing,
                    length: length
                };

                // Add to map
                arrowLine.addTo(this.map);
                arrowheadLines.forEach(line => line.addTo(this.map));
                if (handle) handle.addTo(this.map);

                this.isInteractive = interactive;
                return this.arrowGroup;
            }

            createArrowhead(destination, bearing, color, weight, opacity) {
                const arrowheadLength = 30;
                const arrowheadAngle = 30;
                
                const arrowhead1 = turf.destination(destination, arrowheadLength, bearing + 180 - arrowheadAngle, {units: 'meters'});
                const arrowhead2 = turf.destination(destination, arrowheadLength, bearing + 180 + arrowheadAngle, {units: 'meters'});
                
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];
                
                const line1 = L.polyline([[endLat, endLon], [arrowhead1.geometry.coordinates[1], arrowhead1.geometry.coordinates[0]]], {
                    color: color,
                    weight: weight,
                    opacity: opacity
                });
                
                const line2 = L.polyline([[endLat, endLon], [arrowhead2.geometry.coordinates[1], arrowhead2.geometry.coordinates[0]]], {
                    color: color,
                    weight: weight,
                    opacity: opacity
                });

                return [line1, line2];
            }

            updateArrow(bearing, updateHandle = true) {
                if (!this.arrowGroup) return;

                const [lat, lon] = this.arrowGroup.center;
                const start = [lon, lat];
                const destination = turf.destination(start, this.arrowGroup.length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Update arrow line
                this.arrowGroup.line.setLatLngs([[lat, lon], [endLat, endLon]]);

                // Update arrowhead
                const newArrowheads = this.createArrowhead(destination, bearing, 
                    this.arrowGroup.line.options.color, 
                    this.arrowGroup.line.options.weight, 
                    this.arrowGroup.line.options.opacity);

                // Remove old arrowheads
                this.arrowGroup.arrowheads.forEach(line => this.map.removeLayer(line));

                // Add new arrowheads
                newArrowheads.forEach(line => line.addTo(this.map));
                this.arrowGroup.arrowheads = newArrowheads;

                // Update handle if not dragging
                if (updateHandle && this.arrowGroup.handle) {
                    this.arrowGroup.handle.setLatLng([endLat, endLon]);
                }

                this.arrowGroup.bearing = bearing;
            }

            clear() {
                if (this.arrowGroup) {
                    this.map.removeLayer(this.arrowGroup.line);
                    this.arrowGroup.arrowheads.forEach(line => this.map.removeLayer(line));
                    if (this.arrowGroup.handle) {
                        this.map.removeLayer(this.arrowGroup.handle);
                    }
                    this.arrowGroup = null;
                }
            }

            addSunArrow(lat, lon, bearing, color = '#DC816E', length = 70) {
                // Calculate arrow endpoint
                const start = [lon, lat];
                const destination = turf.destination(start, length, bearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];

                // Create arrow line with transparency
                const arrowLine = L.polyline([[lat, lon], [endLat, endLon]], {
                    color: color,
                    weight: 4,
                    opacity: 0.8
                });

                // Create arrowhead
                const arrowheadLines = this.createArrowhead(destination, bearing, color, 4, 0.8);

                // Add to map
                arrowLine.addTo(this.map);
                arrowheadLines.forEach(line => line.addTo(this.map));

                return {
                    line: arrowLine,
                    arrowheads: arrowheadLines
                };
            }
        }

        let arrowManager = null;

        // Function to display address lookup results
        function displayAddressLookup(data) {
            const addressResultDiv = document.getElementById('addressResult');
            
            let html = `
                <p><span class="highlight">Address:</span> ${data.address}</p>
                <div class="coordinates">
                    <strong>Coordinates:</strong> ${data.coordinates.lat.toFixed(6)}, ${data.coordinates.lon.toFixed(6)}
                </div>
            `;
            
            addressResultDiv.innerHTML = html;
            addressResultDiv.className = 'result address';
            addressResultDiv.style.display = 'block';
            
            // Display the map with interactive arrow
            displayMap(data.coordinates.lat, data.coordinates.lon, data.road_bearing);
        }
        
        // Function to create and display the map
        function displayMap(lat, lon, roadBearing) {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.style.display = 'block';
            
            // Store current data
            currentAddress = document.getElementById('address').value;
            currentCoordinates = { lat, lon };
            originalBearing = roadBearing;
            currentBearing = roadBearing;
            originalZoom = 18;
            
            // Update bearing display
            document.getElementById('bearingValue').textContent = `${roadBearing.toFixed(1)}¬∞`;
            
            // Initialize map if it doesn't exist
            if (!map) {
                map = L.map('map', {
                    minZoom: 16,
                    maxZoom: 18
                }).setView([lat, lon], originalZoom);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
                
                arrowManager = new ArrowManager(map);
                
                // Add event listeners for map interaction
                map.on('mousedown', onMapMouseDown);
                map.on('mousemove', onMapMouseMove);
                map.on('mouseup', onMapMouseUp);
            } else {
                map.setView([lat, lon], originalZoom);
                map.eachLayer((layer) => {
                    if (layer instanceof L.Marker || layer instanceof L.Polyline || layer instanceof L.Circle) {
                        map.removeLayer(layer);
                    }
                });
            }
            
            // Add marker for the address
            marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'address-marker',
                    html: '<svg width="24" height="36" viewBox="0 0 24 36" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.383 0 0 5.383 0 12c0 9 12 24 12 24s12-15 12-24c0-6.617-5.383-12-12-12zm0 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z" fill="#2A2B2A"/></svg>',
                    iconSize: [24, 36],
                    iconAnchor: [12, 36]
                })
            }).addTo(map);
            
            // Create interactive arrow
            arrowManager.createArrow(lat, lon, roadBearing, { interactive: true });
            isInteractiveMode = true;
            isDragging = false;
        }

        // Mouse event handlers for arrow interaction
        function onMapMouseDown(e) {
            if (!arrowManager || !arrowManager.arrowGroup || !arrowManager.isInteractive) return;
            
            const handleLatLng = arrowManager.arrowGroup.handle.getLatLng();
            const distance = map.distance(e.latlng, handleLatLng);
            
            if (distance < 80) {
                isDragging = true;
                document.body.classList.add('grabbing');
                
                // Remove handle during dragging
                map.removeLayer(arrowManager.arrowGroup.handle);
                arrowManager.arrowGroup.handle = null;
                
                e.originalEvent.stopPropagation();
                e.originalEvent.preventDefault();
                map.dragging.disable();
            }
        }
        
        function onMapMouseMove(e) {
            if (!isDragging || !arrowManager || !arrowManager.arrowGroup) return;
            
            e.originalEvent.stopPropagation();
            e.originalEvent.preventDefault();
            
            const [centerLat, centerLon] = arrowManager.arrowGroup.center;
            const mouseLat = e.latlng.lat;
            const mouseLon = e.latlng.lng;
            
            const start = [centerLon, centerLat];
            const end = [mouseLon, mouseLat];
            
            const bearing = (turf.bearing(start, end) + 360) % 360;
            
            currentBearing = bearing;
            arrowManager.updateArrow(currentBearing, false);
            document.getElementById('bearingValue').textContent = `${bearing.toFixed(1)}¬∞`;
        }
        
        function onMapMouseUp() {
            if (isDragging && arrowManager && arrowManager.arrowGroup) {
                isDragging = false;
                document.body.classList.remove('grabbing');
                
                // Recreate handle
                const [lat, lon] = arrowManager.arrowGroup.center;
                const start = [lon, lat];
                const destination = turf.destination(start, arrowManager.arrowGroup.length, currentBearing, {units: 'meters'});
                const endLon = destination.geometry.coordinates[0];
                const endLat = destination.geometry.coordinates[1];
                
                arrowManager.arrowGroup.handle = L.marker([endLat, endLon], {
                    icon: L.divIcon({
                        className: 'arrow-handle',
                        html: '<div style="background-color: #2A2B2A; width: 24px; height: 24px; border-radius: 50%; border: 3px solid #fff; cursor: grab;"></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map);
                
                map.dragging.enable();
            }
        }

        // Calculate henge function
        async function calculateHenge() {
            const calculateBtn = document.getElementById('calculateHengeBtn');
            const loading = document.getElementById('loading');
            const hengeResult = document.getElementById('hengeResult');
            
            calculateBtn.disabled = true;
            loading.style.display = 'block';
            hengeResult.style.display = 'none';
            
            try {
                const response = await fetch('/lookup_address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        address: currentAddress,
                        road_bearing: currentBearing
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    displayResult(data);
                    
                    // Replace interactive arrow with static arrows
                    if (data.result.henge_found) {
                        arrowManager.clear();
                        arrowManager.createArrow(currentCoordinates.lat, currentCoordinates.lon, data.road_bearing);
                        arrowManager.addSunArrow(currentCoordinates.lat, currentCoordinates.lon, data.result.sun_angle);
                        
                        // Update map legend
                        document.querySelector('.map-info').innerHTML = 
                            '<strong>Map Legend:</strong> Dark arrow shows road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>. Orange arrow shows sun <span class="tooltip-term">azimuth<span class="tooltip">Angle of a celestial object (e.g. the sun) measured clockwise from True North</span></span>.';
                    } else {
                        arrowManager.clear();
                        arrowManager.createArrow(currentCoordinates.lat, currentCoordinates.lon, data.road_bearing);
                        
                        document.querySelector('.map-info').innerHTML = 
                            '<strong>Map Legend:</strong> Dark arrow shows road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>.';
                    }
                    
                    // Hide interactive elements
                    hideInteractiveElements();
                } else {
                    displayError(data.error);
                }
            } catch (error) {
                displayError('Network error. Please try again.');
            } finally {
                calculateBtn.disabled = false;
                loading.style.display = 'none';
            }
        }

        function hideInteractiveElements() {
            const calculateBtn = document.getElementById('calculateHengeBtn');
            const bearingControls = document.querySelector('.bearing-controls');
            const step2Header = document.querySelector('.map-container h3');
            const step3Header = document.querySelector('.main-action h3');
            
            calculateBtn.style.display = 'none';
            if (bearingControls) bearingControls.style.display = 'none';
            if (step2Header) step2Header.style.display = 'none';
            if (step3Header) step3Header.style.display = 'none';
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('calculateHengeBtn').addEventListener('click', calculateHenge);
            
            document.getElementById('resetBtn').addEventListener('click', function() {
                currentBearing = originalBearing;
                arrowManager.updateArrow(originalBearing);
                document.getElementById('bearingValue').textContent = `${originalBearing.toFixed(1)}¬∞`;
                
                // Reset zoom level to original
                if (map && currentCoordinates) {
                    map.setView([currentCoordinates.lat, currentCoordinates.lon], originalZoom);
                }
            });
        });

        // Form submission
        document.getElementById('hengeForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const address = document.getElementById('address').value;
            const submitBtn = document.getElementById('submitBtn');
            const loading = document.getElementById('loading');
            const addressResult = document.getElementById('addressResult');
            const hengeResult = document.getElementById('hengeResult');
            
            resetToInitialState();
            
            submitBtn.disabled = true;
            loading.style.display = 'block';
            addressResult.style.display = 'none';
            hengeResult.style.display = 'none';
            document.getElementById('mapContainer').style.display = 'none';
            
            try {
                const response = await fetch('/lookup_address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ address: address })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    displayAddressLookup(data);
                } else {
                    displayError(data.error, 'addressResult');
                }
            } catch (error) {
                console.error('Error:', error);
                displayError('Network error. Please try again.', 'addressResult');
            } finally {
                submitBtn.disabled = false;
                loading.style.display = 'none';
            }
        });

        function displayResult(data) {
            const hengeResultDiv = document.getElementById('hengeResult');
            const result = data.result;
            
            let html = '';
            
            if (result.henge_found) {
                html = `
                    <h3>üéâ Henge Found!</h3>
                    <p><span class="highlight">Next Henge Date:</span> ${result.henge_time_local_str ? result.henge_time_local_str : formatDate(result.henge_date)}</p>
                    <p><span class="highlight">Street <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span> ${data.road_bearing}¬∞ from North</p>
                    <p><span class="highlight">Sun <span class="tooltip-term">Azimuth<span class="tooltip">Angle of a celestial object (e.g. the sun) measured clockwise from True North</span></span>:</span> ${result.sun_angle}¬∞ from North</p>
                    <p><em>Perfect alignment! The sun will set directly down your street on this date.</em></p>
                    <div class="disclaimer">
                        <p><span class="topic">Note: These predictions are rough estimates calculations.</span> For official city-wide henge events (like Manhattanhenge), check official announcements. They use specific city reference points and spatial assumptions, which may differ from the street-to-street calculations and assumptions used here.</p>
                    </div>
                `;
                hengeResultDiv.className = 'result success';
            } else {
                html = `
                    <h3>üîç No Henge Found</h3>
                    <p><span class="highlight">Street <span class="tooltip-term">Bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span>:</span> ${data.road_bearing}¬∞ from North</p>
                    <p><em>No henge alignment found in the next ${result.days_searched} days. The sun's path doesn't align with your street's orientation at this location.</em></p>
                    <div class="disclaimer">
                        <p><span class="topic">Note: These predictions are rough calculations based on various assumptions.</span> For official city-wide henge events (like Manhattanhenge), check official announcements as they use specific reference points and may differ from street-to-street calculations here.</p>
                    </div>
                `;
                hengeResultDiv.className = 'result no-henge';
            }
            
            hengeResultDiv.innerHTML = html;
            hengeResultDiv.style.display = 'block';
        }

        function displayError(message, container = 'hengeResult') {
            const errorDiv = document.getElementById(container);
            
            errorDiv.innerHTML = `
                <h3>‚ùå Error</h3>
                <p>${message}</p>
            `;
            errorDiv.className = 'result error';
            errorDiv.style.display = 'block';
            
            // Hide other containers if showing address error
            if (container === 'addressResult') {
                document.getElementById('mapContainer').style.display = 'none';
                document.getElementById('hengeResult').style.display = 'none';
            }
        }

        function resetToInitialState() {
            if (arrowManager) {
                arrowManager.clear();
            }
            
            currentAddress = null;
            currentCoordinates = null;
            originalBearing = 0;
            currentBearing = 0;
            originalZoom = 18;
            isInteractiveMode = false;
            isDragging = false;
            
            // Show all interactive elements again
            const bearingControls = document.querySelector('.bearing-controls');
            if (bearingControls) bearingControls.style.display = 'flex';
            
            const bearingValue = document.getElementById('bearingValue');
            if (bearingValue) {
                bearingValue.style.display = 'inline';
                bearingValue.textContent = '0¬∞';
            }
            
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.style.display = 'inline-block';
            
            const calculateBtn = document.getElementById('calculateHengeBtn');
            if (calculateBtn) calculateBtn.style.display = 'block';
            
            const step2Header = document.querySelector('.map-container h3');
            if (step2Header) step2Header.style.display = 'block';
            
            const step3Header = document.querySelector('.main-action h3');
            if (step3Header) step3Header.style.display = 'block';
            
            document.querySelector('.map-info').innerHTML = 
                '<strong>Map Legend:</strong> Dark arrow shows the road <span class="tooltip-term">bearing<span class="tooltip">Angle of a terrestrial object (e.g. a road) measured clockwise from True North</span></span> direction (drag to adjust).';
            
            if (map) {
                map.dragging.enable();
            }
        }
        
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    </script>
</body>
</html> 